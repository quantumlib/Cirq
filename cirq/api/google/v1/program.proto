syntax = "proto3";

import "cirq/api/google/v1/operations.proto";
import "cirq/api/google/v1/params.proto";

package cirq.api.google.v1;

option java_package = "com.google.cirq.api.google.v1";
option java_outer_classname = "ProgramProto";
option java_multiple_files = true;

// A quantum program. This includes a quantum circuit and also a set of circuit
// parameters over which the circuit should be run.
message Program {
  // Gates and measurements that make up the circuit.
  repeated Operation operations = 1;

  // The circuit parameters for the operations above will be evaluated for
  // each parameter in parameter sweeps.
  repeated ParameterSweep parameter_sweeps = 2;
}

// The parameters used to generate result along with the results for this
// set of parameters.
message ParameterizedResult {
  // The parameter dict that was used when generating these results.
  ParameterDict params = 1;

  // The measurement results. This is a packed representation of all of the
  // measurements for fixed set of parameters (specified by params above)
  // across all of the repetitions for the set of parameters given the
  // params field.
  //
  // The result of a single measurement gate is a single bit. Every Program
  // has a fixed set of measurement gates. These gates are labeled by a key
  // (this key may be repeated). The results of a single run of the program
  // should consist of bits for each of the measurement gates. To order these
  // bits we use the measurement_keys field of the SweepResult. This is an
  // ordered list of measurement keys along with the number of times this
  // measurement key appears in the program (this is the size field in
  // MeasurementKey). We use the ordering of the measurement_keys field to
  // define the bit string a single run of the measurement. That is, if the
  // keys (k_i) and sizes (s_i) are given by the list
  //   (k_0,s_0),(k_1,s_1), ..., (k_{m-1},s_{m-1}),
  // (for m different measurement keys), then the bit string for these
  // measurements is defined as
  //   r_0[0] r_0[1] ... r_0[s_0] r_1[0] r_1[1] ... r_1[s_1] ...
  //   ... r_{m-1}[0] r_{m-1}[1] ... r_{m-1}[s_{m-1}]
  // Here r_i are the measurement results for the ith key (order defined by
  // measurement_keys). Since the ith key can appear s_i times, r_i is a
  // length s_i bit string, and r_i[j] is the jth bit in this string.
  // The order of each r_i bit string (of size s_i) follows the order in which
  // the measurements are specified in the program (recall that this is for a
  // fixed measurement key).
  //
  // The above describes a bit string for a single run of a program with
  // fixed parameters. This program however may be repeated, the number
  // of times the program was run for these parameters is defined by the
  // num_repetitions field of the SweepResult. If R_l is the bit string
  // for the lth repetition of the program (defined by the r_0[0]... bit
  // string above), then the full results is the concatenation of these
  // bit strings
  //   R_0 R_1 ... R_{num_repetitions - 1}
  //
  // Finally this entire bit string is encoded into the bytes of this field
  // using little endian notation. That is, the least significant bit of the
  // bytes is the first bit of the bit string, the second-least significant
  // bit of the bytes is the second bit of the bit string, etc.
  bytes measurement_results = 2;
}

// A message which represents a measurement key, along with the number of
// measurements that are associated with this key.
message MeasurementKey {
  // The measurement key.
  string key = 1;

  // The number of measurements operations in a Program. This is not the number
  // of measurements across all of the ParameterSweeps, but instead is simply
  // the number of times that the measurement with a given key appears in
  // the list of operations in a program.
  int32 size = 2;
}

// The measurement results for a particular ParameterSweep.
message SweepResult {
  // The total number of repetitions that were performed for this sweep.
  // This is reported in order to make it possible to decode the bytes
  // in the measurement results.
  int32 num_repetitions = 1;

  // A list of measurement keys (string) along with the number of measurements
  // for each of these keys. The size of the measurement key is the total
  // number of measurements with that key in the list of operations for
  // the Program.
  //
  // The measurement keys in the repeated list are all unique: if a measurement
  // with the same key is repeated the bit results will come back in the order
  // the gate appears in the Program. See the measurement_results field
  // for documentation on this ordering.
  repeated MeasurementKey measurement_keys = 2;

  // The results along with the parameters that generated these results.
  // These represent the expanded parameters defined int he ParameterSweep
  // which this SweepResult corresponds to.
  repeated ParameterizedResult parameterized_results = 3;
}

// The overall results of running a Program.
message Result {
  // The results for each ParameterSweep. These will be in the same order
  // as the parameter_sweeps repeated field in the Program that generated
  // these results.
  repeated SweepResult sweep_results = 1;
}
