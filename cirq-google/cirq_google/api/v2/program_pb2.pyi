"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import cirq_google.api.v2.ndarrays_pb2
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import tunits.proto.tunits_pb2
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class Program(google.protobuf.message.Message):
    """A quantum program."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LANGUAGE_FIELD_NUMBER: builtins.int
    CIRCUIT_FIELD_NUMBER: builtins.int
    CONSTANTS_FIELD_NUMBER: builtins.int
    KEYED_CIRCUITS_FIELD_NUMBER: builtins.int
    @property
    def language(self) -> Global___Language:
        """The language in which the program is written."""

    @property
    def circuit(self) -> Global___Circuit:
        """A circuit is an abstract representation as a series of moments, each
        moment having a set of gates that act on disjoint qubits. Circuits don't
        have absolute times for their operations (gates acting on qubits).
        """

    @property
    def constants(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___Constant]:
        """List to store global constants, such as strings used in many places.
        constants are referred to their index in this list, starting at zero.
        """

    @property
    def keyed_circuits(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___KeyedCircuit]:
        """A batch of circuits organized by a set of parameters.  These
        parameters should also be specified in the sweep as well.
        This field can be used for efficient packing of circuit functions
        that change based on parameters, or for batch sending of circuits.
        """

    def __init__(
        self,
        *,
        language: Global___Language | None = ...,
        circuit: Global___Circuit | None = ...,
        constants: collections.abc.Iterable[Global___Constant] | None = ...,
        keyed_circuits: collections.abc.Iterable[Global___KeyedCircuit] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["circuit", b"circuit", "language", b"language", "program", b"program"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["circuit", b"circuit", "constants", b"constants", "keyed_circuits", b"keyed_circuits", "language", b"language", "program", b"program"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["program", b"program"]) -> typing.Literal["circuit"] | None: ...

Global___Program: typing_extensions.TypeAlias = Program

@typing.final
class Constant(google.protobuf.message.Message):
    """Constants, such as long strings, that are used throughout the circuit.
    These constants can be stored here to save space.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STRING_VALUE_FIELD_NUMBER: builtins.int
    CIRCUIT_VALUE_FIELD_NUMBER: builtins.int
    QUBIT_FIELD_NUMBER: builtins.int
    MOMENT_VALUE_FIELD_NUMBER: builtins.int
    OPERATION_VALUE_FIELD_NUMBER: builtins.int
    TAG_VALUE_FIELD_NUMBER: builtins.int
    string_value: builtins.str
    """String value used throughout the circuit, such as for token values"""
    @property
    def circuit_value(self) -> Global___Circuit:
        """Sub Circuit used for CircuitOperations"""

    @property
    def qubit(self) -> Global___Qubit:
        """Qubits used within the circuit (only populated in v2.5+)"""

    @property
    def moment_value(self) -> Global___Moment:
        """Moments used multiple times in a circuit"""

    @property
    def operation_value(self) -> Global___Operation:
        """Operations used multiple times in a circuit"""

    @property
    def tag_value(self) -> Global___Tag:
        """Tags used multiple times in a circuit"""

    def __init__(
        self,
        *,
        string_value: builtins.str = ...,
        circuit_value: Global___Circuit | None = ...,
        qubit: Global___Qubit | None = ...,
        moment_value: Global___Moment | None = ...,
        operation_value: Global___Operation | None = ...,
        tag_value: Global___Tag | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["circuit_value", b"circuit_value", "const_value", b"const_value", "moment_value", b"moment_value", "operation_value", b"operation_value", "qubit", b"qubit", "string_value", b"string_value", "tag_value", b"tag_value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["circuit_value", b"circuit_value", "const_value", b"const_value", "moment_value", b"moment_value", "operation_value", b"operation_value", "qubit", b"qubit", "string_value", b"string_value", "tag_value", b"tag_value"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["const_value", b"const_value"]) -> typing.Literal["string_value", "circuit_value", "qubit", "moment_value", "operation_value", "tag_value"] | None: ...

Global___Constant: typing_extensions.TypeAlias = Constant

@typing.final
class KeyedCircuit(google.protobuf.message.Message):
    """A batch of circuits organized by a set of parameters.  These
    parameters should also be specified in the sweep as well.
    This field can be used for efficient packing of circuit functions
    that change based on parameters, or for batch sending of circuits.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class ArgsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> Global___Arg: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: Global___Arg | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    ARGS_FIELD_NUMBER: builtins.int
    CIRCUIT_FIELD_NUMBER: builtins.int
    KEY_FIELD_NUMBER: builtins.int
    key: builtins.str
    """Optional key for program.
    If provided, will be used as a key in a Mapping from string to Circuit.
    """
    @property
    def args(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, Global___Arg]:
        """Arguments for a cirq circuit which comes from run_context.
        The key will be the name of the argument, and the value
        will be the value passed into the function.
        e.g. Arguments for a circuit function such as:
        def circuit_fn(freq_GHz: float, num_cycles: int) -> Circuit
        would have the two entries: "freq_GHz" and "num_cycles"
        """

    @property
    def circuit(self) -> Global___Circuit:
        """The cirq circuit corresponding to the arguments args."""

    def __init__(
        self,
        *,
        args: collections.abc.Mapping[builtins.str, Global___Arg] | None = ...,
        circuit: Global___Circuit | None = ...,
        key: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["circuit", b"circuit"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["args", b"args", "circuit", b"circuit", "key", b"key"]) -> None: ...

Global___KeyedCircuit: typing_extensions.TypeAlias = KeyedCircuit

@typing.final
class Circuit(google.protobuf.message.Message):
    """The quantum circuit, specified as a series of moments (abstract
    slices of times with gates acting on disjoint sets of qubits).
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _SchedulingStrategy:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _SchedulingStrategyEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Circuit._SchedulingStrategy.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        SCHEDULING_STRATEGY_UNSPECIFIED: Circuit._SchedulingStrategy.ValueType  # 0
        """The scheduling strategy is unspecified."""
        MOMENT_BY_MOMENT: Circuit._SchedulingStrategy.ValueType  # 1
        """Each operation in a moment starts at the same time. The start of the
        next moment is given by the duration of the longest operation in
        the current moment.
        """

    class SchedulingStrategy(_SchedulingStrategy, metaclass=_SchedulingStrategyEnumTypeWrapper):
        """How the circuit is scheduled."""

    SCHEDULING_STRATEGY_UNSPECIFIED: Circuit.SchedulingStrategy.ValueType  # 0
    """The scheduling strategy is unspecified."""
    MOMENT_BY_MOMENT: Circuit.SchedulingStrategy.ValueType  # 1
    """Each operation in a moment starts at the same time. The start of the
    next moment is given by the duration of the longest operation in
    the current moment.
    """

    SCHEDULING_STRATEGY_FIELD_NUMBER: builtins.int
    MOMENTS_FIELD_NUMBER: builtins.int
    MOMENT_INDICES_FIELD_NUMBER: builtins.int
    TAG_INDICES_FIELD_NUMBER: builtins.int
    scheduling_strategy: Global___Circuit.SchedulingStrategy.ValueType
    @property
    def moments(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___Moment]:
        """The moments of the circuit, with the first element corresponding to the
        first set of operations to apply, etc.
        """

    @property
    def moment_indices(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The index of the moment in the top-level constant table.
        In order to preserve ordering, either this field should be populated
        or the moments field, but not both.
        This field is used to reduce size of circuits that contain many
        repeated moments.
        """

    @property
    def tag_indices(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Indices in the constant table for tags associated with the circuit"""

    def __init__(
        self,
        *,
        scheduling_strategy: Global___Circuit.SchedulingStrategy.ValueType = ...,
        moments: collections.abc.Iterable[Global___Moment] | None = ...,
        moment_indices: collections.abc.Iterable[builtins.int] | None = ...,
        tag_indices: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["moment_indices", b"moment_indices", "moments", b"moments", "scheduling_strategy", b"scheduling_strategy", "tag_indices", b"tag_indices"]) -> None: ...

Global___Circuit: typing_extensions.TypeAlias = Circuit

@typing.final
class Moment(google.protobuf.message.Message):
    """A moment is a collection of operations and circuit operations that operate
    on a disjoint set of qubits. Conceptually, a moment represents operations
    that all occur in the same finite period of time.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    OPERATIONS_FIELD_NUMBER: builtins.int
    CIRCUIT_OPERATIONS_FIELD_NUMBER: builtins.int
    OPERATION_INDICES_FIELD_NUMBER: builtins.int
    TAG_INDICES_FIELD_NUMBER: builtins.int
    @property
    def operations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___Operation]:
        """All of the gate operations in the moment. Each operation and circuit
        operation must act on different qubits.
        """

    @property
    def circuit_operations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___CircuitOperation]:
        """All of the circuit operations in the moment. Each operation and circuit
        operation must act on different qubits.
        """

    @property
    def operation_indices(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """All of the operations in the moment that are stored in the constants
        table.  Each operation should be stored in either `operations`
        or `operation_indices`.  Putting operations into the symbol
        table should be preferred for circuits with repeated operations
        for improved serialization size.
        """

    @property
    def tag_indices(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Indices in the constant table for tags associated with the circuit"""

    def __init__(
        self,
        *,
        operations: collections.abc.Iterable[Global___Operation] | None = ...,
        circuit_operations: collections.abc.Iterable[Global___CircuitOperation] | None = ...,
        operation_indices: collections.abc.Iterable[builtins.int] | None = ...,
        tag_indices: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["circuit_operations", b"circuit_operations", "operation_indices", b"operation_indices", "operations", b"operations", "tag_indices", b"tag_indices"]) -> None: ...

Global___Moment: typing_extensions.TypeAlias = Moment

@typing.final
class Language(google.protobuf.message.Message):
    """The language in which the program is expressed."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    GATE_SET_FIELD_NUMBER: builtins.int
    ARG_FUNCTION_LANGUAGE_FIELD_NUMBER: builtins.int
    gate_set: builtins.str
    """The name of the gate set being used.

    Valid names for the gate sets can be found in
    cirq_google/serialization/gate_sets.py.

    Deprecated: A device now only supports a single gate set.
    Previously, the value of this field also refers to the name of the
    serializer for the program. Currently, the only serializer available is
    CircuitSerializer in cirq_google/serialization/circuit_serializer.py.
    """
    arg_function_language: builtins.str
    """The language supported by ArgFunctions. These specifies what allowed
    ArgFunction types there are.

    Valid names for the arg function language can be found in
    cirq/google/arg_func_langs.py
    """
    def __init__(
        self,
        *,
        gate_set: builtins.str = ...,
        arg_function_language: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["arg_function_language", b"arg_function_language", "gate_set", b"gate_set"]) -> None: ...

Global___Language: typing_extensions.TypeAlias = Language

@typing.final
class FloatArg(google.protobuf.message.Message):
    """Argument that is constrained to a float or symbolic expression"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    FLOAT_VALUE_FIELD_NUMBER: builtins.int
    SYMBOL_FIELD_NUMBER: builtins.int
    FUNC_FIELD_NUMBER: builtins.int
    float_value: builtins.float
    symbol: builtins.str
    @property
    def func(self) -> Global___ArgFunction: ...
    def __init__(
        self,
        *,
        float_value: builtins.float = ...,
        symbol: builtins.str = ...,
        func: Global___ArgFunction | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["arg", b"arg", "float_value", b"float_value", "func", b"func", "symbol", b"symbol"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["arg", b"arg", "float_value", b"float_value", "func", b"func", "symbol", b"symbol"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["arg", b"arg"]) -> typing.Literal["float_value", "symbol", "func"] | None: ...

Global___FloatArg: typing_extensions.TypeAlias = FloatArg

@typing.final
class XPowGate(google.protobuf.message.Message):
    """Representation of cirq.XPowGate"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    EXPONENT_FIELD_NUMBER: builtins.int
    @property
    def exponent(self) -> Global___FloatArg: ...
    def __init__(
        self,
        *,
        exponent: Global___FloatArg | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["exponent", b"exponent"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["exponent", b"exponent"]) -> None: ...

Global___XPowGate: typing_extensions.TypeAlias = XPowGate

@typing.final
class YPowGate(google.protobuf.message.Message):
    """Representation of cirq.YPowGate"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    EXPONENT_FIELD_NUMBER: builtins.int
    @property
    def exponent(self) -> Global___FloatArg: ...
    def __init__(
        self,
        *,
        exponent: Global___FloatArg | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["exponent", b"exponent"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["exponent", b"exponent"]) -> None: ...

Global___YPowGate: typing_extensions.TypeAlias = YPowGate

@typing.final
class ZPowGate(google.protobuf.message.Message):
    """Representation of cirq.ZPowGate"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    EXPONENT_FIELD_NUMBER: builtins.int
    IS_PHYSICAL_Z_FIELD_NUMBER: builtins.int
    is_physical_z: builtins.bool
    """If true, this is equivalent to:
    cirq.ZPowGate(...).with_tags(cirq.google.PhysicalZTag)
    """
    @property
    def exponent(self) -> Global___FloatArg: ...
    def __init__(
        self,
        *,
        exponent: Global___FloatArg | None = ...,
        is_physical_z: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["exponent", b"exponent"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["exponent", b"exponent", "is_physical_z", b"is_physical_z"]) -> None: ...

Global___ZPowGate: typing_extensions.TypeAlias = ZPowGate

@typing.final
class PhasedXPowGate(google.protobuf.message.Message):
    """Representation of cirq.PhasedXPowGate"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PHASE_EXPONENT_FIELD_NUMBER: builtins.int
    EXPONENT_FIELD_NUMBER: builtins.int
    @property
    def phase_exponent(self) -> Global___FloatArg: ...
    @property
    def exponent(self) -> Global___FloatArg: ...
    def __init__(
        self,
        *,
        phase_exponent: Global___FloatArg | None = ...,
        exponent: Global___FloatArg | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["exponent", b"exponent", "phase_exponent", b"phase_exponent"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["exponent", b"exponent", "phase_exponent", b"phase_exponent"]) -> None: ...

Global___PhasedXPowGate: typing_extensions.TypeAlias = PhasedXPowGate

@typing.final
class PhasedXZGate(google.protobuf.message.Message):
    """Representation of cirq.PhasedXZGate"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    X_EXPONENT_FIELD_NUMBER: builtins.int
    Z_EXPONENT_FIELD_NUMBER: builtins.int
    AXIS_PHASE_EXPONENT_FIELD_NUMBER: builtins.int
    @property
    def x_exponent(self) -> Global___FloatArg: ...
    @property
    def z_exponent(self) -> Global___FloatArg: ...
    @property
    def axis_phase_exponent(self) -> Global___FloatArg: ...
    def __init__(
        self,
        *,
        x_exponent: Global___FloatArg | None = ...,
        z_exponent: Global___FloatArg | None = ...,
        axis_phase_exponent: Global___FloatArg | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["axis_phase_exponent", b"axis_phase_exponent", "x_exponent", b"x_exponent", "z_exponent", b"z_exponent"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["axis_phase_exponent", b"axis_phase_exponent", "x_exponent", b"x_exponent", "z_exponent", b"z_exponent"]) -> None: ...

Global___PhasedXZGate: typing_extensions.TypeAlias = PhasedXZGate

@typing.final
class CZPowGate(google.protobuf.message.Message):
    """Representation of cirq.CZPowGate"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    EXPONENT_FIELD_NUMBER: builtins.int
    @property
    def exponent(self) -> Global___FloatArg: ...
    def __init__(
        self,
        *,
        exponent: Global___FloatArg | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["exponent", b"exponent"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["exponent", b"exponent"]) -> None: ...

Global___CZPowGate: typing_extensions.TypeAlias = CZPowGate

@typing.final
class FSimGate(google.protobuf.message.Message):
    """Representation of cirq.FSimGate"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    THETA_FIELD_NUMBER: builtins.int
    PHI_FIELD_NUMBER: builtins.int
    TRANSLATE_VIA_MODEL_FIELD_NUMBER: builtins.int
    translate_via_model: builtins.bool
    """If true, this is equivalent to:
    cirq.FSimGate(...).with_tags(cirq_google.FSimViaModelTag()).
    This field controls how we translate the gate implementation.
    """
    @property
    def theta(self) -> Global___FloatArg: ...
    @property
    def phi(self) -> Global___FloatArg: ...
    def __init__(
        self,
        *,
        theta: Global___FloatArg | None = ...,
        phi: Global___FloatArg | None = ...,
        translate_via_model: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["phi", b"phi", "theta", b"theta"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["phi", b"phi", "theta", b"theta", "translate_via_model", b"translate_via_model"]) -> None: ...

Global___FSimGate: typing_extensions.TypeAlias = FSimGate

@typing.final
class ISwapPowGate(google.protobuf.message.Message):
    """Representation of cirq.ISwapPowGate"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    EXPONENT_FIELD_NUMBER: builtins.int
    @property
    def exponent(self) -> Global___FloatArg: ...
    def __init__(
        self,
        *,
        exponent: Global___FloatArg | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["exponent", b"exponent"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["exponent", b"exponent"]) -> None: ...

Global___ISwapPowGate: typing_extensions.TypeAlias = ISwapPowGate

@typing.final
class ISwapLikeGate(google.protobuf.message.Message):
    """Representation of an iswap-like gate
    with theta=pi/2 and a non-zero hardware-dependent phi angle
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _OriginalCirqGate:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _OriginalCirqGateEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ISwapLikeGate._OriginalCirqGate.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNSPECIFIED: ISwapLikeGate._OriginalCirqGate.ValueType  # 0
        SYCAMORE: ISwapLikeGate._OriginalCirqGate.ValueType  # 1
        WILLOW: ISwapLikeGate._OriginalCirqGate.ValueType  # 2

    class OriginalCirqGate(_OriginalCirqGate, metaclass=_OriginalCirqGateEnumTypeWrapper):
        """Original gate, for deserializing faithfully."""

    UNSPECIFIED: ISwapLikeGate.OriginalCirqGate.ValueType  # 0
    SYCAMORE: ISwapLikeGate.OriginalCirqGate.ValueType  # 1
    WILLOW: ISwapLikeGate.OriginalCirqGate.ValueType  # 2

    ORIGINAL_GATE_FIELD_NUMBER: builtins.int
    original_gate: Global___ISwapLikeGate.OriginalCirqGate.ValueType
    def __init__(
        self,
        *,
        original_gate: Global___ISwapLikeGate.OriginalCirqGate.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["original_gate", b"original_gate"]) -> None: ...

Global___ISwapLikeGate: typing_extensions.TypeAlias = ISwapLikeGate

@typing.final
class MeasurementGate(google.protobuf.message.Message):
    """Representation of cirq.MeasurementGate
    i.e. cirq.measure
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    INVERT_MASK_FIELD_NUMBER: builtins.int
    @property
    def key(self) -> Global___Arg: ...
    @property
    def invert_mask(self) -> Global___Arg: ...
    def __init__(
        self,
        *,
        key: Global___Arg | None = ...,
        invert_mask: Global___Arg | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["invert_mask", b"invert_mask", "key", b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["invert_mask", b"invert_mask", "key", b"key"]) -> None: ...

Global___MeasurementGate: typing_extensions.TypeAlias = MeasurementGate

@typing.final
class WaitGate(google.protobuf.message.Message):
    """Representation of cirq.WaitGate"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DURATION_NANOS_FIELD_NUMBER: builtins.int
    @property
    def duration_nanos(self) -> Global___FloatArg:
        """Duration of the waiting period,
        serialized to the number of nanoseconds
        """

    def __init__(
        self,
        *,
        duration_nanos: Global___FloatArg | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["duration_nanos", b"duration_nanos"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["duration_nanos", b"duration_nanos"]) -> None: ...

Global___WaitGate: typing_extensions.TypeAlias = WaitGate

@typing.final
class DepolarizingChannel(google.protobuf.message.Message):
    """Representation of cirq.DepolarizingChannel"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PROBABILITY_FIELD_NUMBER: builtins.int
    NUM_QUBITS_FIELD_NUMBER: builtins.int
    num_qubits: builtins.int
    @property
    def probability(self) -> Global___FloatArg: ...
    def __init__(
        self,
        *,
        probability: Global___FloatArg | None = ...,
        num_qubits: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["probability", b"probability"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["num_qubits", b"num_qubits", "probability", b"probability"]) -> None: ...

Global___DepolarizingChannel: typing_extensions.TypeAlias = DepolarizingChannel

@typing.final
class RandomGateChannel(google.protobuf.message.Message):
    """Representation of cirq.RandomGateChannel"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PROBABILITY_FIELD_NUMBER: builtins.int
    SUB_GATE_FIELD_NUMBER: builtins.int
    @property
    def probability(self) -> Global___FloatArg: ...
    @property
    def sub_gate(self) -> Global___Operation: ...
    def __init__(
        self,
        *,
        probability: Global___FloatArg | None = ...,
        sub_gate: Global___Operation | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["probability", b"probability", "sub_gate", b"sub_gate"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["probability", b"probability", "sub_gate", b"sub_gate"]) -> None: ...

Global___RandomGateChannel: typing_extensions.TypeAlias = RandomGateChannel

@typing.final
class NoiseChannel(google.protobuf.message.Message):
    """Representation of noisy channels
    These should only be used for serialization
    of noisy circuits for simulation.
    These channels would generally not be supported
    by hardware.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DEPOLARIZINGCHANNEL_FIELD_NUMBER: builtins.int
    RANDOMGATECHANNEL_FIELD_NUMBER: builtins.int
    @property
    def depolarizingchannel(self) -> Global___DepolarizingChannel: ...
    @property
    def randomgatechannel(self) -> Global___RandomGateChannel: ...
    def __init__(
        self,
        *,
        depolarizingchannel: Global___DepolarizingChannel | None = ...,
        randomgatechannel: Global___RandomGateChannel | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["channel_value", b"channel_value", "depolarizingchannel", b"depolarizingchannel", "randomgatechannel", b"randomgatechannel"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["channel_value", b"channel_value", "depolarizingchannel", b"depolarizingchannel", "randomgatechannel", b"randomgatechannel"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["channel_value", b"channel_value"]) -> typing.Literal["depolarizingchannel", "randomgatechannel"] | None: ...

Global___NoiseChannel: typing_extensions.TypeAlias = NoiseChannel

@typing.final
class AnalogDetuneCouplerOnly(google.protobuf.message.Message):
    """Representation of cirq_google.ops.AnalogDetuneCouplerOnly
    All the following fields should be specified as the tunit.Value.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LENGTH_FIELD_NUMBER: builtins.int
    W_FIELD_NUMBER: builtins.int
    G_0_FIELD_NUMBER: builtins.int
    G_MAX_FIELD_NUMBER: builtins.int
    G_RAMP_EXPONENT_FIELD_NUMBER: builtins.int
    NEIGHBOR_QUBITS_FREQ_FIELD_NUMBER: builtins.int
    PREV_NEIGHBOR_QUBITS_FREQ_FIELD_NUMBER: builtins.int
    INTERPOLATE_COUPLING_CAL_FIELD_NUMBER: builtins.int
    ANALOG_CAL_FOR_PULSESHAPING_FIELD_NUMBER: builtins.int
    interpolate_coupling_cal: builtins.bool
    analog_cal_for_pulseshaping: builtins.bool
    @property
    def length(self) -> Global___Arg:
        """The duration of gate"""

    @property
    def w(self) -> Global___Arg:
        """Width of the step envelope raising edge"""

    @property
    def g_0(self) -> Global___Arg:
        """Coupler strength specified with the equation g(t) = g_0+A*t^g_exp.
        See AnalogDetuneCouplerOnly for details.
        """

    @property
    def g_max(self) -> Global___Arg: ...
    @property
    def g_ramp_exponent(self) -> Global___Arg: ...
    @property
    def neighbor_qubits_freq(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___Arg]:
        """Two frequencies of the neighbor qubits at the moment."""

    @property
    def prev_neighbor_qubits_freq(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___Arg]:
        """Two frequencies of the neighbor qubits at preivous moment."""

    def __init__(
        self,
        *,
        length: Global___Arg | None = ...,
        w: Global___Arg | None = ...,
        g_0: Global___Arg | None = ...,
        g_max: Global___Arg | None = ...,
        g_ramp_exponent: Global___Arg | None = ...,
        neighbor_qubits_freq: collections.abc.Iterable[Global___Arg] | None = ...,
        prev_neighbor_qubits_freq: collections.abc.Iterable[Global___Arg] | None = ...,
        interpolate_coupling_cal: builtins.bool = ...,
        analog_cal_for_pulseshaping: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["g_0", b"g_0", "g_max", b"g_max", "g_ramp_exponent", b"g_ramp_exponent", "length", b"length", "w", b"w"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["analog_cal_for_pulseshaping", b"analog_cal_for_pulseshaping", "g_0", b"g_0", "g_max", b"g_max", "g_ramp_exponent", b"g_ramp_exponent", "interpolate_coupling_cal", b"interpolate_coupling_cal", "length", b"length", "neighbor_qubits_freq", b"neighbor_qubits_freq", "prev_neighbor_qubits_freq", b"prev_neighbor_qubits_freq", "w", b"w"]) -> None: ...

Global___AnalogDetuneCouplerOnly: typing_extensions.TypeAlias = AnalogDetuneCouplerOnly

@typing.final
class AnalogDetuneQubit(google.protobuf.message.Message):
    """Representation of cirq_google.ops.AnalogDetuneQubit
    All the following fields should be specified as the tunit.Value.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LENGTH_FIELD_NUMBER: builtins.int
    W_FIELD_NUMBER: builtins.int
    TARGET_FREQ_FIELD_NUMBER: builtins.int
    PREV_FREQ_FIELD_NUMBER: builtins.int
    NEIGHBOR_COUPLER_G_DICT_FIELD_NUMBER: builtins.int
    PREV_NEIGHBOR_COUPLER_G_DICT_FIELD_NUMBER: builtins.int
    LINEAR_RISE_FIELD_NUMBER: builtins.int
    linear_rise: builtins.bool
    """If True, the rising edge will be a linear function."""
    @property
    def length(self) -> Global___Arg:
        """The duration of gate"""

    @property
    def w(self) -> Global___Arg:
        """Width of the step envelope raising edge"""

    @property
    def target_freq(self) -> Global___Arg:
        """The target frequency for the qubit at end of detune gate."""

    @property
    def prev_freq(self) -> Global___Arg:
        """Previous detuning frequency to compensate beginning of detune gate."""

    @property
    def neighbor_coupler_g_dict(self) -> Global___ArgMapping:
        """A dictionary has coupler name like "c_q0_0_q1_0" as key and the coupling strength `g` as the value."""

    @property
    def prev_neighbor_coupler_g_dict(self) -> Global___ArgMapping: ...
    def __init__(
        self,
        *,
        length: Global___Arg | None = ...,
        w: Global___Arg | None = ...,
        target_freq: Global___Arg | None = ...,
        prev_freq: Global___Arg | None = ...,
        neighbor_coupler_g_dict: Global___ArgMapping | None = ...,
        prev_neighbor_coupler_g_dict: Global___ArgMapping | None = ...,
        linear_rise: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["length", b"length", "neighbor_coupler_g_dict", b"neighbor_coupler_g_dict", "prev_freq", b"prev_freq", "prev_neighbor_coupler_g_dict", b"prev_neighbor_coupler_g_dict", "target_freq", b"target_freq", "w", b"w"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["length", b"length", "linear_rise", b"linear_rise", "neighbor_coupler_g_dict", b"neighbor_coupler_g_dict", "prev_freq", b"prev_freq", "prev_neighbor_coupler_g_dict", b"prev_neighbor_coupler_g_dict", "target_freq", b"target_freq", "w", b"w"]) -> None: ...

Global___AnalogDetuneQubit: typing_extensions.TypeAlias = AnalogDetuneQubit

@typing.final
class WaitGateWithUnit(google.protobuf.message.Message):
    """Representation of cirq_google.ops.WaitGateWithUnit"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DURATION_FIELD_NUMBER: builtins.int
    QID_SHAPE_FIELD_NUMBER: builtins.int
    @property
    def duration(self) -> Global___Arg: ...
    @property
    def qid_shape(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]: ...
    def __init__(
        self,
        *,
        duration: Global___Arg | None = ...,
        qid_shape: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["duration", b"duration"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["duration", b"duration", "qid_shape", b"qid_shape"]) -> None: ...

Global___WaitGateWithUnit: typing_extensions.TypeAlias = WaitGateWithUnit

@typing.final
class Operation(google.protobuf.message.Message):
    """An operation acts on a set of qubits.
    next available id = 31
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    XPOWGATE_FIELD_NUMBER: builtins.int
    YPOWGATE_FIELD_NUMBER: builtins.int
    ZPOWGATE_FIELD_NUMBER: builtins.int
    PHASEDXPOWGATE_FIELD_NUMBER: builtins.int
    PHASEDXZGATE_FIELD_NUMBER: builtins.int
    CZPOWGATE_FIELD_NUMBER: builtins.int
    FSIMGATE_FIELD_NUMBER: builtins.int
    ISWAPPOWGATE_FIELD_NUMBER: builtins.int
    MEASUREMENTGATE_FIELD_NUMBER: builtins.int
    WAITGATE_FIELD_NUMBER: builtins.int
    INTERNALGATE_FIELD_NUMBER: builtins.int
    COUPLERPULSEGATE_FIELD_NUMBER: builtins.int
    IDENTITYGATE_FIELD_NUMBER: builtins.int
    HPOWGATE_FIELD_NUMBER: builtins.int
    SINGLEQUBITCLIFFORDGATE_FIELD_NUMBER: builtins.int
    RESETGATE_FIELD_NUMBER: builtins.int
    ISWAPLIKEGATE_FIELD_NUMBER: builtins.int
    NOISECHANNEL_FIELD_NUMBER: builtins.int
    ANALOG_DETUNE_COUPLER_ONLY_FIELD_NUMBER: builtins.int
    ANALOG_DETUNE_QUBIT_FIELD_NUMBER: builtins.int
    WAIT_GATE_WITH_UNIT_FIELD_NUMBER: builtins.int
    QUBITS_FIELD_NUMBER: builtins.int
    QUBIT_CONSTANT_INDEX_FIELD_NUMBER: builtins.int
    TOKEN_VALUE_FIELD_NUMBER: builtins.int
    TOKEN_CONSTANT_INDEX_FIELD_NUMBER: builtins.int
    TAGS_FIELD_NUMBER: builtins.int
    TAG_INDICES_FIELD_NUMBER: builtins.int
    CONDITIONED_ON_FIELD_NUMBER: builtins.int
    token_value: builtins.str
    token_constant_index: builtins.int
    @property
    def xpowgate(self) -> Global___XPowGate: ...
    @property
    def ypowgate(self) -> Global___YPowGate: ...
    @property
    def zpowgate(self) -> Global___ZPowGate: ...
    @property
    def phasedxpowgate(self) -> Global___PhasedXPowGate: ...
    @property
    def phasedxzgate(self) -> Global___PhasedXZGate: ...
    @property
    def czpowgate(self) -> Global___CZPowGate: ...
    @property
    def fsimgate(self) -> Global___FSimGate: ...
    @property
    def iswappowgate(self) -> Global___ISwapPowGate: ...
    @property
    def measurementgate(self) -> Global___MeasurementGate: ...
    @property
    def waitgate(self) -> Global___WaitGate: ...
    @property
    def internalgate(self) -> Global___InternalGate: ...
    @property
    def couplerpulsegate(self) -> Global___CouplerPulseGate: ...
    @property
    def identitygate(self) -> Global___IdentityGate: ...
    @property
    def hpowgate(self) -> Global___HPowGate: ...
    @property
    def singlequbitcliffordgate(self) -> Global___SingleQubitCliffordGate: ...
    @property
    def resetgate(self) -> Global___ResetGate: ...
    @property
    def iswaplikegate(self) -> Global___ISwapLikeGate: ...
    @property
    def noisechannel(self) -> Global___NoiseChannel: ...
    @property
    def analog_detune_coupler_only(self) -> Global___AnalogDetuneCouplerOnly: ...
    @property
    def analog_detune_qubit(self) -> Global___AnalogDetuneQubit: ...
    @property
    def wait_gate_with_unit(self) -> Global___WaitGateWithUnit: ...
    @property
    def qubits(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___Qubit]:
        """Which qubits the operation acts on.
        Operations should populate one of the following two
        fields: either to specify the qubit directly or
        to reference an index in the enclosing Program's
        constant messages.  Note that qubit_constant_index
        will only be populated in v2.5+
        """

    @property
    def qubit_constant_index(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]: ...
    @property
    def tags(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___Tag]:
        """To be deprecated"""

    @property
    def tag_indices(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Indices in the constant table for tags associated with the operation"""

    @property
    def conditioned_on(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___Arg]:
        """Classical conditions
        Note that this condition is not a sympy expression
        as it has a relation such as "==", "<" etc
        """

    def __init__(
        self,
        *,
        xpowgate: Global___XPowGate | None = ...,
        ypowgate: Global___YPowGate | None = ...,
        zpowgate: Global___ZPowGate | None = ...,
        phasedxpowgate: Global___PhasedXPowGate | None = ...,
        phasedxzgate: Global___PhasedXZGate | None = ...,
        czpowgate: Global___CZPowGate | None = ...,
        fsimgate: Global___FSimGate | None = ...,
        iswappowgate: Global___ISwapPowGate | None = ...,
        measurementgate: Global___MeasurementGate | None = ...,
        waitgate: Global___WaitGate | None = ...,
        internalgate: Global___InternalGate | None = ...,
        couplerpulsegate: Global___CouplerPulseGate | None = ...,
        identitygate: Global___IdentityGate | None = ...,
        hpowgate: Global___HPowGate | None = ...,
        singlequbitcliffordgate: Global___SingleQubitCliffordGate | None = ...,
        resetgate: Global___ResetGate | None = ...,
        iswaplikegate: Global___ISwapLikeGate | None = ...,
        noisechannel: Global___NoiseChannel | None = ...,
        analog_detune_coupler_only: Global___AnalogDetuneCouplerOnly | None = ...,
        analog_detune_qubit: Global___AnalogDetuneQubit | None = ...,
        wait_gate_with_unit: Global___WaitGateWithUnit | None = ...,
        qubits: collections.abc.Iterable[Global___Qubit] | None = ...,
        qubit_constant_index: collections.abc.Iterable[builtins.int] | None = ...,
        token_value: builtins.str = ...,
        token_constant_index: builtins.int = ...,
        tags: collections.abc.Iterable[Global___Tag] | None = ...,
        tag_indices: collections.abc.Iterable[builtins.int] | None = ...,
        conditioned_on: collections.abc.Iterable[Global___Arg] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["analog_detune_coupler_only", b"analog_detune_coupler_only", "analog_detune_qubit", b"analog_detune_qubit", "couplerpulsegate", b"couplerpulsegate", "czpowgate", b"czpowgate", "fsimgate", b"fsimgate", "gate_value", b"gate_value", "hpowgate", b"hpowgate", "identitygate", b"identitygate", "internalgate", b"internalgate", "iswaplikegate", b"iswaplikegate", "iswappowgate", b"iswappowgate", "measurementgate", b"measurementgate", "noisechannel", b"noisechannel", "phasedxpowgate", b"phasedxpowgate", "phasedxzgate", b"phasedxzgate", "resetgate", b"resetgate", "singlequbitcliffordgate", b"singlequbitcliffordgate", "token", b"token", "token_constant_index", b"token_constant_index", "token_value", b"token_value", "wait_gate_with_unit", b"wait_gate_with_unit", "waitgate", b"waitgate", "xpowgate", b"xpowgate", "ypowgate", b"ypowgate", "zpowgate", b"zpowgate"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["analog_detune_coupler_only", b"analog_detune_coupler_only", "analog_detune_qubit", b"analog_detune_qubit", "conditioned_on", b"conditioned_on", "couplerpulsegate", b"couplerpulsegate", "czpowgate", b"czpowgate", "fsimgate", b"fsimgate", "gate_value", b"gate_value", "hpowgate", b"hpowgate", "identitygate", b"identitygate", "internalgate", b"internalgate", "iswaplikegate", b"iswaplikegate", "iswappowgate", b"iswappowgate", "measurementgate", b"measurementgate", "noisechannel", b"noisechannel", "phasedxpowgate", b"phasedxpowgate", "phasedxzgate", b"phasedxzgate", "qubit_constant_index", b"qubit_constant_index", "qubits", b"qubits", "resetgate", b"resetgate", "singlequbitcliffordgate", b"singlequbitcliffordgate", "tag_indices", b"tag_indices", "tags", b"tags", "token", b"token", "token_constant_index", b"token_constant_index", "token_value", b"token_value", "wait_gate_with_unit", b"wait_gate_with_unit", "waitgate", b"waitgate", "xpowgate", b"xpowgate", "ypowgate", b"ypowgate", "zpowgate", b"zpowgate"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["gate_value", b"gate_value"]) -> typing.Literal["xpowgate", "ypowgate", "zpowgate", "phasedxpowgate", "phasedxzgate", "czpowgate", "fsimgate", "iswappowgate", "measurementgate", "waitgate", "internalgate", "couplerpulsegate", "identitygate", "hpowgate", "singlequbitcliffordgate", "resetgate", "iswaplikegate", "noisechannel", "analog_detune_coupler_only", "analog_detune_qubit", "wait_gate_with_unit"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["token", b"token"]) -> typing.Literal["token_value", "token_constant_index"] | None: ...

Global___Operation: typing_extensions.TypeAlias = Operation

@typing.final
class DynamicalDecouplingTag(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PROTOCOL_FIELD_NUMBER: builtins.int
    protocol: builtins.str
    def __init__(
        self,
        *,
        protocol: builtins.str | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_protocol", b"_protocol", "protocol", b"protocol"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_protocol", b"_protocol", "protocol", b"protocol"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["_protocol", b"_protocol"]) -> typing.Literal["protocol"] | None: ...

Global___DynamicalDecouplingTag: typing_extensions.TypeAlias = DynamicalDecouplingTag

@typing.final
class Tag(google.protobuf.message.Message):
    """Messages for tags that can modify operations
    These are often directives to hardware specifying
    how the operation should be executed.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DYNAMICAL_DECOUPLING_FIELD_NUMBER: builtins.int
    NO_SYNC_FIELD_NUMBER: builtins.int
    PHASE_MATCH_FIELD_NUMBER: builtins.int
    PHYSICAL_Z_FIELD_NUMBER: builtins.int
    CLASSICAL_STATE_FIELD_NUMBER: builtins.int
    FSIM_VIA_MODEL_FIELD_NUMBER: builtins.int
    CALIBRATION_TAG_FIELD_NUMBER: builtins.int
    COMPRESS_DURATION_FIELD_NUMBER: builtins.int
    INTERNAL_TAG_FIELD_NUMBER: builtins.int
    RAW_VALUE_FIELD_NUMBER: builtins.int
    @property
    def dynamical_decoupling(self) -> Global___DynamicalDecouplingTag:
        """Tag to denote a composite dynamical decoupling operation.
        Should generally be applied to cirq.I gates.
        """

    @property
    def no_sync(self) -> Global___NoSyncTag:
        """Directs the hardware to ignore moment-based
        synchronization and to instead schedule
        operations as soon as possible for these qubits.
        """

    @property
    def phase_match(self) -> Global___PhaseMatchTag:
        """Operation should do phase matching to match phase
        required for subsequent operations
        """

    @property
    def physical_z(self) -> Global___PhysicalZTag:
        """Only applicable to Z gates and other gates
        that have Z gates as part of their internal operation
        This indicates that the Z gates could be executed on
        hardware rather than be computed virtually as part
        of phase matching.
        """

    @property
    def classical_state(self) -> Global___ClassicalStateTag:
        """Indicates that the operations are classical states"""

    @property
    def fsim_via_model(self) -> Global___FSimViaModelTag:
        """Field id 6 Reserved for OverlayTag, will add in a subsequent PR.

        Uses parameter model to interpolate FSim gate.
        """

    @property
    def calibration_tag(self) -> Global___CalibrationTag:
        """Calibration Tag"""

    @property
    def compress_duration(self) -> Global___CompressDurationTag:
        """Compress duration to zero, if possible."""

    @property
    def internal_tag(self) -> Global___InternalTag:
        """Catch-all for all gates that do not fit into the
        above tags.
        """

    @property
    def raw_value(self) -> Global___Arg:
        """Raw Types such as strings and other values"""

    def __init__(
        self,
        *,
        dynamical_decoupling: Global___DynamicalDecouplingTag | None = ...,
        no_sync: Global___NoSyncTag | None = ...,
        phase_match: Global___PhaseMatchTag | None = ...,
        physical_z: Global___PhysicalZTag | None = ...,
        classical_state: Global___ClassicalStateTag | None = ...,
        fsim_via_model: Global___FSimViaModelTag | None = ...,
        calibration_tag: Global___CalibrationTag | None = ...,
        compress_duration: Global___CompressDurationTag | None = ...,
        internal_tag: Global___InternalTag | None = ...,
        raw_value: Global___Arg | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["calibration_tag", b"calibration_tag", "classical_state", b"classical_state", "compress_duration", b"compress_duration", "dynamical_decoupling", b"dynamical_decoupling", "fsim_via_model", b"fsim_via_model", "internal_tag", b"internal_tag", "no_sync", b"no_sync", "phase_match", b"phase_match", "physical_z", b"physical_z", "raw_value", b"raw_value", "tag", b"tag"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["calibration_tag", b"calibration_tag", "classical_state", b"classical_state", "compress_duration", b"compress_duration", "dynamical_decoupling", b"dynamical_decoupling", "fsim_via_model", b"fsim_via_model", "internal_tag", b"internal_tag", "no_sync", b"no_sync", "phase_match", b"phase_match", "physical_z", b"physical_z", "raw_value", b"raw_value", "tag", b"tag"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["tag", b"tag"]) -> typing.Literal["dynamical_decoupling", "no_sync", "phase_match", "physical_z", "classical_state", "fsim_via_model", "calibration_tag", "compress_duration", "internal_tag", "raw_value"] | None: ...

Global___Tag: typing_extensions.TypeAlias = Tag

@typing.final
class PhaseMatchTag(google.protobuf.message.Message):
    """Tag for operations that should do phase matching to match phase
    required for subsequent operations
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___PhaseMatchTag: typing_extensions.TypeAlias = PhaseMatchTag

@typing.final
class PhysicalZTag(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___PhysicalZTag: typing_extensions.TypeAlias = PhysicalZTag

@typing.final
class ClassicalStateTag(google.protobuf.message.Message):
    """Tag to indicate that a state prep circuit produces a classical state.
    This serves as a hint to the compiler that we can ignore virtual Z phases
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___ClassicalStateTag: typing_extensions.TypeAlias = ClassicalStateTag

@typing.final
class FSimViaModelTag(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___FSimViaModelTag: typing_extensions.TypeAlias = FSimViaModelTag

@typing.final
class NoSyncTag(google.protobuf.message.Message):
    """Tag to remove moment-based synchronization
    The reverse and forward arguments control the
    number of moments to reverse synchronization.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    REVERSE_FIELD_NUMBER: builtins.int
    REMOVE_ALL_SYNCS_BEFORE_FIELD_NUMBER: builtins.int
    FORWARD_FIELD_NUMBER: builtins.int
    REMOVE_ALL_SYNCS_AFTER_FIELD_NUMBER: builtins.int
    reverse: builtins.int
    """Number of synchronizations before the operation to remove"""
    remove_all_syncs_before: builtins.bool
    """Remove all possible synchronizations"""
    forward: builtins.int
    """Number of synchronizations after the operation to remove"""
    remove_all_syncs_after: builtins.bool
    """Remove all possible synchronizations"""
    def __init__(
        self,
        *,
        reverse: builtins.int = ...,
        remove_all_syncs_before: builtins.bool = ...,
        forward: builtins.int = ...,
        remove_all_syncs_after: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["forward", b"forward", "fwd", b"fwd", "remove_all_syncs_after", b"remove_all_syncs_after", "remove_all_syncs_before", b"remove_all_syncs_before", "rev", b"rev", "reverse", b"reverse"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["forward", b"forward", "fwd", b"fwd", "remove_all_syncs_after", b"remove_all_syncs_after", "remove_all_syncs_before", b"remove_all_syncs_before", "rev", b"rev", "reverse", b"reverse"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["fwd", b"fwd"]) -> typing.Literal["forward", "remove_all_syncs_after"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["rev", b"rev"]) -> typing.Literal["reverse", "remove_all_syncs_before"] | None: ...

Global___NoSyncTag: typing_extensions.TypeAlias = NoSyncTag

@typing.final
class CalibrationTag(google.protobuf.message.Message):
    """Tag to specify specific override tokens for operations or circuits."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TOKEN_FIELD_NUMBER: builtins.int
    token: builtins.str
    """Token to serialize"""
    def __init__(
        self,
        *,
        token: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["token", b"token"]) -> None: ...

Global___CalibrationTag: typing_extensions.TypeAlias = CalibrationTag

@typing.final
class CompressDurationTag(google.protobuf.message.Message):
    """Tag to specify that hardware should compress the duration to zero
    if possible.  For instance, in X**0 or PhasedXZGate with zero angles.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___CompressDurationTag: typing_extensions.TypeAlias = CompressDurationTag

@typing.final
class InternalTag(google.protobuf.message.Message):
    """Tag to represent any internal tags or tags not yet
    implemented in the proto.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class TagArgsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> Global___Arg: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: Global___Arg | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    @typing.final
    class CustomArgsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> Global___CustomArg: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: Global___CustomArg | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    TAG_NAME_FIELD_NUMBER: builtins.int
    TAG_PACKAGE_FIELD_NUMBER: builtins.int
    TAG_ARGS_FIELD_NUMBER: builtins.int
    CUSTOM_ARGS_FIELD_NUMBER: builtins.int
    tag_name: builtins.str
    """Name of the tag"""
    tag_package: builtins.str
    """Python package of the Tag"""
    @property
    def tag_args(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, Global___Arg]:
        """Instantiation arguments of the Tag"""

    @property
    def custom_args(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, Global___CustomArg]: ...
    def __init__(
        self,
        *,
        tag_name: builtins.str = ...,
        tag_package: builtins.str = ...,
        tag_args: collections.abc.Mapping[builtins.str, Global___Arg] | None = ...,
        custom_args: collections.abc.Mapping[builtins.str, Global___CustomArg] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["custom_args", b"custom_args", "tag_args", b"tag_args", "tag_name", b"tag_name", "tag_package", b"tag_package"]) -> None: ...

Global___InternalTag: typing_extensions.TypeAlias = InternalTag

@typing.final
class Gate(google.protobuf.message.Message):
    """The instruction identifying the action taken on the quantum computer."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    id: builtins.str
    """Name for the Gate.

    These names must match those specified in the gate set.  This is found
    in cirq/google/gate_sets.py.
    """
    def __init__(
        self,
        *,
        id: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["id", b"id"]) -> None: ...

Global___Gate: typing_extensions.TypeAlias = Gate

@typing.final
class Qubit(google.protobuf.message.Message):
    """An identifier for a qubit."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    id: builtins.str
    """Id of the qubit. These depend on the device being scheduled upon.

    Typically ids for qubits on a line are simple string versions of integers,
    while for qubits on a square grid these are integers separated by a
    underscore, i.e. '0_1', '1_2', etc.
    """
    def __init__(
        self,
        *,
        id: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["id", b"id"]) -> None: ...

Global___Qubit: typing_extensions.TypeAlias = Qubit

@typing.final
class Arg(google.protobuf.message.Message):
    """Arguments needed to specify a gate."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ARG_VALUE_FIELD_NUMBER: builtins.int
    SYMBOL_FIELD_NUMBER: builtins.int
    FUNC_FIELD_NUMBER: builtins.int
    CONSTANT_INDEX_FIELD_NUMBER: builtins.int
    MEASUREMENT_KEY_FIELD_NUMBER: builtins.int
    symbol: builtins.str
    constant_index: builtins.int
    @property
    def arg_value(self) -> Global___ArgValue: ...
    @property
    def func(self) -> Global___ArgFunction: ...
    @property
    def measurement_key(self) -> Global___MeasurementKey: ...
    def __init__(
        self,
        *,
        arg_value: Global___ArgValue | None = ...,
        symbol: builtins.str = ...,
        func: Global___ArgFunction | None = ...,
        constant_index: builtins.int = ...,
        measurement_key: Global___MeasurementKey | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["arg", b"arg", "arg_value", b"arg_value", "constant_index", b"constant_index", "func", b"func", "measurement_key", b"measurement_key", "symbol", b"symbol"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["arg", b"arg", "arg_value", b"arg_value", "constant_index", b"constant_index", "func", b"func", "measurement_key", b"measurement_key", "symbol", b"symbol"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["arg", b"arg"]) -> typing.Literal["arg_value", "symbol", "func", "constant_index", "measurement_key"] | None: ...

Global___Arg: typing_extensions.TypeAlias = Arg

@typing.final
class ArgValue(google.protobuf.message.Message):
    """Value that can be passed as an argument to a gate."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    FLOAT_VALUE_FIELD_NUMBER: builtins.int
    BOOL_VALUES_FIELD_NUMBER: builtins.int
    STRING_VALUE_FIELD_NUMBER: builtins.int
    DOUBLE_VALUE_FIELD_NUMBER: builtins.int
    INT64_VALUES_FIELD_NUMBER: builtins.int
    DOUBLE_VALUES_FIELD_NUMBER: builtins.int
    STRING_VALUES_FIELD_NUMBER: builtins.int
    VALUE_WITH_UNIT_FIELD_NUMBER: builtins.int
    BOOL_VALUE_FIELD_NUMBER: builtins.int
    BYTES_VALUE_FIELD_NUMBER: builtins.int
    COMPLEX_VALUE_FIELD_NUMBER: builtins.int
    TUPLE_VALUE_FIELD_NUMBER: builtins.int
    NDARRAY_VALUE_FIELD_NUMBER: builtins.int
    float_value: builtins.float
    string_value: builtins.str
    double_value: builtins.float
    bool_value: builtins.bool
    bytes_value: builtins.bytes
    @property
    def bool_values(self) -> Global___RepeatedBoolean: ...
    @property
    def int64_values(self) -> Global___RepeatedInt64: ...
    @property
    def double_values(self) -> Global___RepeatedDouble: ...
    @property
    def string_values(self) -> Global___RepeatedString: ...
    @property
    def value_with_unit(self) -> tunits.proto.tunits_pb2.Value: ...
    @property
    def complex_value(self) -> Global___Complex: ...
    @property
    def tuple_value(self) -> Global___Tuple: ...
    @property
    def ndarray_value(self) -> Global___NDArray: ...
    def __init__(
        self,
        *,
        float_value: builtins.float = ...,
        bool_values: Global___RepeatedBoolean | None = ...,
        string_value: builtins.str = ...,
        double_value: builtins.float = ...,
        int64_values: Global___RepeatedInt64 | None = ...,
        double_values: Global___RepeatedDouble | None = ...,
        string_values: Global___RepeatedString | None = ...,
        value_with_unit: tunits.proto.tunits_pb2.Value | None = ...,
        bool_value: builtins.bool = ...,
        bytes_value: builtins.bytes = ...,
        complex_value: Global___Complex | None = ...,
        tuple_value: Global___Tuple | None = ...,
        ndarray_value: Global___NDArray | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["arg_value", b"arg_value", "bool_value", b"bool_value", "bool_values", b"bool_values", "bytes_value", b"bytes_value", "complex_value", b"complex_value", "double_value", b"double_value", "double_values", b"double_values", "float_value", b"float_value", "int64_values", b"int64_values", "ndarray_value", b"ndarray_value", "string_value", b"string_value", "string_values", b"string_values", "tuple_value", b"tuple_value", "value_with_unit", b"value_with_unit"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["arg_value", b"arg_value", "bool_value", b"bool_value", "bool_values", b"bool_values", "bytes_value", b"bytes_value", "complex_value", b"complex_value", "double_value", b"double_value", "double_values", b"double_values", "float_value", b"float_value", "int64_values", b"int64_values", "ndarray_value", b"ndarray_value", "string_value", b"string_value", "string_values", b"string_values", "tuple_value", b"tuple_value", "value_with_unit", b"value_with_unit"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["arg_value", b"arg_value"]) -> typing.Literal["float_value", "bool_values", "string_value", "double_value", "int64_values", "double_values", "string_values", "value_with_unit", "bool_value", "bytes_value", "complex_value", "tuple_value", "ndarray_value"] | None: ...

Global___ArgValue: typing_extensions.TypeAlias = ArgValue

@typing.final
class RepeatedInt64(google.protobuf.message.Message):
    """A repeated int value."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUES_FIELD_NUMBER: builtins.int
    @property
    def values(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]: ...
    def __init__(
        self,
        *,
        values: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["values", b"values"]) -> None: ...

Global___RepeatedInt64: typing_extensions.TypeAlias = RepeatedInt64

@typing.final
class RepeatedDouble(google.protobuf.message.Message):
    """A repeated double value."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUES_FIELD_NUMBER: builtins.int
    @property
    def values(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]: ...
    def __init__(
        self,
        *,
        values: collections.abc.Iterable[builtins.float] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["values", b"values"]) -> None: ...

Global___RepeatedDouble: typing_extensions.TypeAlias = RepeatedDouble

@typing.final
class RepeatedString(google.protobuf.message.Message):
    """A repeated string value."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUES_FIELD_NUMBER: builtins.int
    @property
    def values(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]: ...
    def __init__(
        self,
        *,
        values: collections.abc.Iterable[builtins.str] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["values", b"values"]) -> None: ...

Global___RepeatedString: typing_extensions.TypeAlias = RepeatedString

@typing.final
class RepeatedBoolean(google.protobuf.message.Message):
    """A repeated boolean value."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VALUES_FIELD_NUMBER: builtins.int
    @property
    def values(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.bool]: ...
    def __init__(
        self,
        *,
        values: collections.abc.Iterable[builtins.bool] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["values", b"values"]) -> None: ...

Global___RepeatedBoolean: typing_extensions.TypeAlias = RepeatedBoolean

@typing.final
class Tuple(google.protobuf.message.Message):
    """Representation of a mixed tuple of values"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _SequenceType:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _SequenceTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Tuple._SequenceType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNSPECIFIED: Tuple._SequenceType.ValueType  # 0
        LIST: Tuple._SequenceType.ValueType  # 1
        TUPLE: Tuple._SequenceType.ValueType  # 2
        SET: Tuple._SequenceType.ValueType  # 3
        FROZENSET: Tuple._SequenceType.ValueType  # 4

    class SequenceType(_SequenceType, metaclass=_SequenceTypeEnumTypeWrapper):
        """Original (python) type of the data"""

    UNSPECIFIED: Tuple.SequenceType.ValueType  # 0
    LIST: Tuple.SequenceType.ValueType  # 1
    TUPLE: Tuple.SequenceType.ValueType  # 2
    SET: Tuple.SequenceType.ValueType  # 3
    FROZENSET: Tuple.SequenceType.ValueType  # 4

    SEQUENCE_TYPE_FIELD_NUMBER: builtins.int
    VALUES_FIELD_NUMBER: builtins.int
    sequence_type: Global___Tuple.SequenceType.ValueType
    @property
    def values(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___Arg]: ...
    def __init__(
        self,
        *,
        sequence_type: Global___Tuple.SequenceType.ValueType = ...,
        values: collections.abc.Iterable[Global___Arg] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["sequence_type", b"sequence_type", "values", b"values"]) -> None: ...

Global___Tuple: typing_extensions.TypeAlias = Tuple

@typing.final
class Complex(google.protobuf.message.Message):
    """Representation of a complex number"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    REAL_VALUE_FIELD_NUMBER: builtins.int
    IMAG_VALUE_FIELD_NUMBER: builtins.int
    real_value: builtins.float
    imag_value: builtins.float
    def __init__(
        self,
        *,
        real_value: builtins.float = ...,
        imag_value: builtins.float = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["imag_value", b"imag_value", "real_value", b"real_value"]) -> None: ...

Global___Complex: typing_extensions.TypeAlias = Complex

@typing.final
class NDArray(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    COMPLEX128_ARRAY_FIELD_NUMBER: builtins.int
    COMPLEX64_ARRAY_FIELD_NUMBER: builtins.int
    FLOAT16_ARRAY_FIELD_NUMBER: builtins.int
    FLOAT32_ARRAY_FIELD_NUMBER: builtins.int
    FLOAT64_ARRAY_FIELD_NUMBER: builtins.int
    INT64_ARRAY_FIELD_NUMBER: builtins.int
    INT32_ARRAY_FIELD_NUMBER: builtins.int
    INT16_ARRAY_FIELD_NUMBER: builtins.int
    INT8_ARRAY_FIELD_NUMBER: builtins.int
    UINT8_ARRAY_FIELD_NUMBER: builtins.int
    BIT_ARRAY_FIELD_NUMBER: builtins.int
    @property
    def complex128_array(self) -> cirq_google.api.v2.ndarrays_pb2.Complex128Array: ...
    @property
    def complex64_array(self) -> cirq_google.api.v2.ndarrays_pb2.Complex64Array: ...
    @property
    def float16_array(self) -> cirq_google.api.v2.ndarrays_pb2.Float16Array: ...
    @property
    def float32_array(self) -> cirq_google.api.v2.ndarrays_pb2.Float32Array: ...
    @property
    def float64_array(self) -> cirq_google.api.v2.ndarrays_pb2.Float64Array: ...
    @property
    def int64_array(self) -> cirq_google.api.v2.ndarrays_pb2.Int64Array: ...
    @property
    def int32_array(self) -> cirq_google.api.v2.ndarrays_pb2.Int32Array: ...
    @property
    def int16_array(self) -> cirq_google.api.v2.ndarrays_pb2.Int16Array: ...
    @property
    def int8_array(self) -> cirq_google.api.v2.ndarrays_pb2.Int8Array: ...
    @property
    def uint8_array(self) -> cirq_google.api.v2.ndarrays_pb2.UInt8Array: ...
    @property
    def bit_array(self) -> cirq_google.api.v2.ndarrays_pb2.BitArray: ...
    def __init__(
        self,
        *,
        complex128_array: cirq_google.api.v2.ndarrays_pb2.Complex128Array | None = ...,
        complex64_array: cirq_google.api.v2.ndarrays_pb2.Complex64Array | None = ...,
        float16_array: cirq_google.api.v2.ndarrays_pb2.Float16Array | None = ...,
        float32_array: cirq_google.api.v2.ndarrays_pb2.Float32Array | None = ...,
        float64_array: cirq_google.api.v2.ndarrays_pb2.Float64Array | None = ...,
        int64_array: cirq_google.api.v2.ndarrays_pb2.Int64Array | None = ...,
        int32_array: cirq_google.api.v2.ndarrays_pb2.Int32Array | None = ...,
        int16_array: cirq_google.api.v2.ndarrays_pb2.Int16Array | None = ...,
        int8_array: cirq_google.api.v2.ndarrays_pb2.Int8Array | None = ...,
        uint8_array: cirq_google.api.v2.ndarrays_pb2.UInt8Array | None = ...,
        bit_array: cirq_google.api.v2.ndarrays_pb2.BitArray | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["arr", b"arr", "bit_array", b"bit_array", "complex128_array", b"complex128_array", "complex64_array", b"complex64_array", "float16_array", b"float16_array", "float32_array", b"float32_array", "float64_array", b"float64_array", "int16_array", b"int16_array", "int32_array", b"int32_array", "int64_array", b"int64_array", "int8_array", b"int8_array", "uint8_array", b"uint8_array"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["arr", b"arr", "bit_array", b"bit_array", "complex128_array", b"complex128_array", "complex64_array", b"complex64_array", "float16_array", b"float16_array", "float32_array", b"float32_array", "float64_array", b"float64_array", "int16_array", b"int16_array", "int32_array", b"int32_array", "int64_array", b"int64_array", "int8_array", b"int8_array", "uint8_array", b"uint8_array"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["arr", b"arr"]) -> typing.Literal["complex128_array", "complex64_array", "float16_array", "float32_array", "float64_array", "int64_array", "int32_array", "int16_array", "int8_array", "uint8_array", "bit_array"] | None: ...

Global___NDArray: typing_extensions.TypeAlias = NDArray

@typing.final
class ArgFunction(google.protobuf.message.Message):
    """A function of arguments. This is an s-expression tree representing
    mathematically the function being evaluated.

    What language is supported is specified by the arg_function_language
    in the language message.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TYPE_FIELD_NUMBER: builtins.int
    ARGS_FIELD_NUMBER: builtins.int
    type: builtins.str
    """The name of the function. I.e. if the function is the sum of two symbols,
    this could be '+', and the args would be two string symbol values.

    Valid values for the type are given in cirq/google/arg_func_langs.py
    and must be consistent with the arg_function_language specified in the
    language field of the program.
    """
    @property
    def args(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___Arg]:
        """The arguments to the function."""

    def __init__(
        self,
        *,
        type: builtins.str = ...,
        args: collections.abc.Iterable[Global___Arg] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["args", b"args", "type", b"type"]) -> None: ...

Global___ArgFunction: typing_extensions.TypeAlias = ArgFunction

@typing.final
class CircuitOperation(google.protobuf.message.Message):
    """An operation that applies a modified version of a reference circuit. The
    circuit is stored in the top-level Constants table; the mappings in this
    object specify how that circuit should be modified for this operation.

    Multiple CircuitOperations may reference the same base circuit even if their
    mappings of that circuit are different.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CIRCUIT_CONSTANT_INDEX_FIELD_NUMBER: builtins.int
    REPETITION_SPECIFICATION_FIELD_NUMBER: builtins.int
    QUBIT_MAP_FIELD_NUMBER: builtins.int
    MEASUREMENT_KEY_MAP_FIELD_NUMBER: builtins.int
    ARG_MAP_FIELD_NUMBER: builtins.int
    REPEAT_UNTIL_FIELD_NUMBER: builtins.int
    CONDITIONED_ON_FIELD_NUMBER: builtins.int
    USE_REPETITION_IDS_FIELD_NUMBER: builtins.int
    circuit_constant_index: builtins.int
    """The index of the circuit in the top-level constant table."""
    use_repetition_ids: builtins.bool
    @property
    def repetition_specification(self) -> Global___RepetitionSpecification:
        """Specifier for repetitions of the circuit, which contains either a number
        of repetitions or a list of repetition IDs.
        """

    @property
    def qubit_map(self) -> Global___QubitMapping:
        """Map from qubits in the "inner" circuit (referenced by
        circuit_constant_index) to qubits in the "outer" circuit (the one that
        contains this operation).
        """

    @property
    def measurement_key_map(self) -> Global___MeasurementKeyMapping:
        """Map of measurement keys in the "inner" circuit (referenced by
        circuit_constant_index) to measurement keys in the "outer" circuit (the
        one that contains this operation).
        """

    @property
    def arg_map(self) -> Global___ArgMapping:
        """Map of args in the "inner" circuit (referenced by circuit_constant_index)
        to args in the "outer" circuit (the one that contains this operation).
        """

    @property
    def repeat_until(self) -> Global___Arg:
        """Classical conditions
        Condition for repeating the circuit until this condition is true.
        """

    @property
    def conditioned_on(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___Arg]:
        """Condition for executing the circuit operation only if this condition is true."""

    def __init__(
        self,
        *,
        circuit_constant_index: builtins.int = ...,
        repetition_specification: Global___RepetitionSpecification | None = ...,
        qubit_map: Global___QubitMapping | None = ...,
        measurement_key_map: Global___MeasurementKeyMapping | None = ...,
        arg_map: Global___ArgMapping | None = ...,
        repeat_until: Global___Arg | None = ...,
        conditioned_on: collections.abc.Iterable[Global___Arg] | None = ...,
        use_repetition_ids: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_repeat_until", b"_repeat_until", "arg_map", b"arg_map", "measurement_key_map", b"measurement_key_map", "qubit_map", b"qubit_map", "repeat_until", b"repeat_until", "repetition_specification", b"repetition_specification"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_repeat_until", b"_repeat_until", "arg_map", b"arg_map", "circuit_constant_index", b"circuit_constant_index", "conditioned_on", b"conditioned_on", "measurement_key_map", b"measurement_key_map", "qubit_map", b"qubit_map", "repeat_until", b"repeat_until", "repetition_specification", b"repetition_specification", "use_repetition_ids", b"use_repetition_ids"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["_repeat_until", b"_repeat_until"]) -> typing.Literal["repeat_until"] | None: ...

Global___CircuitOperation: typing_extensions.TypeAlias = CircuitOperation

@typing.final
class RepetitionSpecification(google.protobuf.message.Message):
    """A description of the repetitions of a subcircuit. IDs are used as suffixes
    for measurements in the repeated subcircuit; if repetition_count is given
    instead, the IDs will simply be the integers [0..N-1].
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class RepetitionIds(google.protobuf.message.Message):
        """An ordered list of IDs for a sequence of repetitions."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        IDS_FIELD_NUMBER: builtins.int
        @property
        def ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]: ...
        def __init__(
            self,
            *,
            ids: collections.abc.Iterable[builtins.str] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["ids", b"ids"]) -> None: ...

    REPETITION_IDS_FIELD_NUMBER: builtins.int
    REPETITION_COUNT_FIELD_NUMBER: builtins.int
    repetition_count: builtins.int
    """An integer number of repetitions to perform."""
    @property
    def repetition_ids(self) -> Global___RepetitionSpecification.RepetitionIds:
        """A list of unique IDs, one per repetition of the subcircuit."""

    def __init__(
        self,
        *,
        repetition_ids: Global___RepetitionSpecification.RepetitionIds | None = ...,
        repetition_count: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["repetition_count", b"repetition_count", "repetition_ids", b"repetition_ids", "repetition_value", b"repetition_value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["repetition_count", b"repetition_count", "repetition_ids", b"repetition_ids", "repetition_value", b"repetition_value"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["repetition_value", b"repetition_value"]) -> typing.Literal["repetition_ids", "repetition_count"] | None: ...

Global___RepetitionSpecification: typing_extensions.TypeAlias = RepetitionSpecification

@typing.final
class QubitMapping(google.protobuf.message.Message):
    """A mapping of qubits from one value to another. All mappings are applied
    simultaneously and independently; for example, [(a, b), (b, a)] will swap
    qubits a and b.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class QubitEntry(google.protobuf.message.Message):
        """Indicates that qubit "key" should be replaced with "value"."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        @property
        def key(self) -> Global___Qubit: ...
        @property
        def value(self) -> Global___Qubit: ...
        def __init__(
            self,
            *,
            key: Global___Qubit | None = ...,
            value: Global___Qubit | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    ENTRIES_FIELD_NUMBER: builtins.int
    @property
    def entries(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___QubitMapping.QubitEntry]:
        """A list of qubit mappings to apply."""

    def __init__(
        self,
        *,
        entries: collections.abc.Iterable[Global___QubitMapping.QubitEntry] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["entries", b"entries"]) -> None: ...

Global___QubitMapping: typing_extensions.TypeAlias = QubitMapping

@typing.final
class MeasurementKey(google.protobuf.message.Message):
    """A key for matching a measurement event to its results."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STRING_KEY_FIELD_NUMBER: builtins.int
    PATH_FIELD_NUMBER: builtins.int
    INDEX_FIELD_NUMBER: builtins.int
    string_key: builtins.str
    index: builtins.int
    """Used in classical conditions to specify which measurement
    should be used if the measurement is repeated.
    Specified as a negative number meaning how many measurements ago.
    If not specified, default is -1, meaning the last measured value.
    """
    @property
    def path(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Used in conditional statements representing the path to the key
        in a multi-level circuit (with repeated or nested circuits).
        See cirq.MeasurementKey for more details.
        """

    def __init__(
        self,
        *,
        string_key: builtins.str = ...,
        path: collections.abc.Iterable[builtins.str] | None = ...,
        index: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_index", b"_index", "index", b"index"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_index", b"_index", "index", b"index", "path", b"path", "string_key", b"string_key"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["_index", b"_index"]) -> typing.Literal["index"] | None: ...

Global___MeasurementKey: typing_extensions.TypeAlias = MeasurementKey

@typing.final
class MeasurementKeyMapping(google.protobuf.message.Message):
    """A mapping of measurement keys from one value to another. All mappings are
    applied simultaneously and independently; for example, [(a, b), (b, a)] will
    swap measurement keys a and b.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class MeasurementKeyEntry(google.protobuf.message.Message):
        """Indicates that measurement key "key" should be replaced with "value"."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        @property
        def key(self) -> Global___MeasurementKey: ...
        @property
        def value(self) -> Global___MeasurementKey: ...
        def __init__(
            self,
            *,
            key: Global___MeasurementKey | None = ...,
            value: Global___MeasurementKey | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    ENTRIES_FIELD_NUMBER: builtins.int
    @property
    def entries(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___MeasurementKeyMapping.MeasurementKeyEntry]:
        """A list of measurement key mappings to apply."""

    def __init__(
        self,
        *,
        entries: collections.abc.Iterable[Global___MeasurementKeyMapping.MeasurementKeyEntry] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["entries", b"entries"]) -> None: ...

Global___MeasurementKeyMapping: typing_extensions.TypeAlias = MeasurementKeyMapping

@typing.final
class ArgMapping(google.protobuf.message.Message):
    """A mapping of args from one value to another. All mappings are applied
    simultaneously and independently; for example, [(a, b), (b, a)] will swap
    args a and b.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class ArgEntry(google.protobuf.message.Message):
        """Indicates that arg "key" should be replaced with "value"."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        @property
        def key(self) -> Global___Arg: ...
        @property
        def value(self) -> Global___Arg: ...
        def __init__(
            self,
            *,
            key: Global___Arg | None = ...,
            value: Global___Arg | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    ENTRIES_FIELD_NUMBER: builtins.int
    @property
    def entries(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___ArgMapping.ArgEntry]:
        """A list of arg mappings to apply."""

    def __init__(
        self,
        *,
        entries: collections.abc.Iterable[Global___ArgMapping.ArgEntry] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["entries", b"entries"]) -> None: ...

Global___ArgMapping: typing_extensions.TypeAlias = ArgMapping

@typing.final
class FunctionInterpolation(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    X_VALUES_FIELD_NUMBER: builtins.int
    Y_VALUES_FIELD_NUMBER: builtins.int
    @property
    def x_values(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """The x_values must be sorted in ascending order.
        The x_values and y_values must be of the same length.
        The independent variable.
        """

    @property
    def y_values(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """The dependent variable."""

    def __init__(
        self,
        *,
        x_values: collections.abc.Iterable[builtins.float] | None = ...,
        y_values: collections.abc.Iterable[builtins.float] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["x_values", b"x_values", "y_values", b"y_values"]) -> None: ...

Global___FunctionInterpolation: typing_extensions.TypeAlias = FunctionInterpolation

@typing.final
class CustomArg(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    FUNCTION_INTERPOLATION_DATA_FIELD_NUMBER: builtins.int
    @property
    def function_interpolation_data(self) -> Global___FunctionInterpolation: ...
    def __init__(
        self,
        *,
        function_interpolation_data: Global___FunctionInterpolation | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["custom_arg", b"custom_arg", "function_interpolation_data", b"function_interpolation_data"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["custom_arg", b"custom_arg", "function_interpolation_data", b"function_interpolation_data"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["custom_arg", b"custom_arg"]) -> typing.Literal["function_interpolation_data"] | None: ...

Global___CustomArg: typing_extensions.TypeAlias = CustomArg

@typing.final
class InternalGate(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class GateArgsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> Global___Arg: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: Global___Arg | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    @typing.final
    class CustomArgsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> Global___CustomArg: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: Global___CustomArg | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    MODULE_FIELD_NUMBER: builtins.int
    NUM_QUBITS_FIELD_NUMBER: builtins.int
    GATE_ARGS_FIELD_NUMBER: builtins.int
    CUSTOM_ARGS_FIELD_NUMBER: builtins.int
    name: builtins.str
    """Gate name."""
    module: builtins.str
    """Gate module."""
    num_qubits: builtins.int
    """Number of qubits. Required during deserialization."""
    @property
    def gate_args(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, Global___Arg]:
        """Gate args."""

    @property
    def custom_args(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, Global___CustomArg]:
        """Custom args are arguments that require special processing during
        deserialization. The `key` is the argument in the internal class's
        constructor, the `value` is a representation from which an internal object
        can be constructed.
        """

    def __init__(
        self,
        *,
        name: builtins.str = ...,
        module: builtins.str = ...,
        num_qubits: builtins.int = ...,
        gate_args: collections.abc.Mapping[builtins.str, Global___Arg] | None = ...,
        custom_args: collections.abc.Mapping[builtins.str, Global___CustomArg] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["custom_args", b"custom_args", "gate_args", b"gate_args", "module", b"module", "name", b"name", "num_qubits", b"num_qubits"]) -> None: ...

Global___InternalGate: typing_extensions.TypeAlias = InternalGate

@typing.final
class CouplerPulseGate(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    HOLD_TIME_PS_FIELD_NUMBER: builtins.int
    RISE_TIME_PS_FIELD_NUMBER: builtins.int
    PADDING_TIME_PS_FIELD_NUMBER: builtins.int
    COUPLING_MHZ_FIELD_NUMBER: builtins.int
    Q0_DETUNE_MHZ_FIELD_NUMBER: builtins.int
    Q1_DETUNE_MHZ_FIELD_NUMBER: builtins.int
    @property
    def hold_time_ps(self) -> Global___FloatArg:
        """ps=picoseconds."""

    @property
    def rise_time_ps(self) -> Global___FloatArg:
        """ps=picoseconds."""

    @property
    def padding_time_ps(self) -> Global___FloatArg:
        """ps=picoseconds."""

    @property
    def coupling_mhz(self) -> Global___FloatArg: ...
    @property
    def q0_detune_mhz(self) -> Global___FloatArg: ...
    @property
    def q1_detune_mhz(self) -> Global___FloatArg: ...
    def __init__(
        self,
        *,
        hold_time_ps: Global___FloatArg | None = ...,
        rise_time_ps: Global___FloatArg | None = ...,
        padding_time_ps: Global___FloatArg | None = ...,
        coupling_mhz: Global___FloatArg | None = ...,
        q0_detune_mhz: Global___FloatArg | None = ...,
        q1_detune_mhz: Global___FloatArg | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_coupling_mhz", b"_coupling_mhz", "_hold_time_ps", b"_hold_time_ps", "_padding_time_ps", b"_padding_time_ps", "_q0_detune_mhz", b"_q0_detune_mhz", "_q1_detune_mhz", b"_q1_detune_mhz", "_rise_time_ps", b"_rise_time_ps", "coupling_mhz", b"coupling_mhz", "hold_time_ps", b"hold_time_ps", "padding_time_ps", b"padding_time_ps", "q0_detune_mhz", b"q0_detune_mhz", "q1_detune_mhz", b"q1_detune_mhz", "rise_time_ps", b"rise_time_ps"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_coupling_mhz", b"_coupling_mhz", "_hold_time_ps", b"_hold_time_ps", "_padding_time_ps", b"_padding_time_ps", "_q0_detune_mhz", b"_q0_detune_mhz", "_q1_detune_mhz", b"_q1_detune_mhz", "_rise_time_ps", b"_rise_time_ps", "coupling_mhz", b"coupling_mhz", "hold_time_ps", b"hold_time_ps", "padding_time_ps", b"padding_time_ps", "q0_detune_mhz", b"q0_detune_mhz", "q1_detune_mhz", b"q1_detune_mhz", "rise_time_ps", b"rise_time_ps"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_coupling_mhz", b"_coupling_mhz"]) -> typing.Literal["coupling_mhz"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_hold_time_ps", b"_hold_time_ps"]) -> typing.Literal["hold_time_ps"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_padding_time_ps", b"_padding_time_ps"]) -> typing.Literal["padding_time_ps"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_q0_detune_mhz", b"_q0_detune_mhz"]) -> typing.Literal["q0_detune_mhz"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_q1_detune_mhz", b"_q1_detune_mhz"]) -> typing.Literal["q1_detune_mhz"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_rise_time_ps", b"_rise_time_ps"]) -> typing.Literal["rise_time_ps"] | None: ...

Global___CouplerPulseGate: typing_extensions.TypeAlias = CouplerPulseGate

@typing.final
class CliffordTableau(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NUM_QUBITS_FIELD_NUMBER: builtins.int
    INITIAL_STATE_FIELD_NUMBER: builtins.int
    RS_FIELD_NUMBER: builtins.int
    XS_FIELD_NUMBER: builtins.int
    ZS_FIELD_NUMBER: builtins.int
    num_qubits: builtins.int
    """Number of qubits the CliffordTableau acts on."""
    initial_state: builtins.int
    """The initial state."""
    @property
    def rs(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.bool]:
        """A flattened version of the `rs` array."""

    @property
    def xs(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.bool]:
        """A flattened version of the `xs` array."""

    @property
    def zs(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.bool]:
        """A flattened version of the `zs` array."""

    def __init__(
        self,
        *,
        num_qubits: builtins.int | None = ...,
        initial_state: builtins.int | None = ...,
        rs: collections.abc.Iterable[builtins.bool] | None = ...,
        xs: collections.abc.Iterable[builtins.bool] | None = ...,
        zs: collections.abc.Iterable[builtins.bool] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_initial_state", b"_initial_state", "_num_qubits", b"_num_qubits", "initial_state", b"initial_state", "num_qubits", b"num_qubits"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_initial_state", b"_initial_state", "_num_qubits", b"_num_qubits", "initial_state", b"initial_state", "num_qubits", b"num_qubits", "rs", b"rs", "xs", b"xs", "zs", b"zs"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_initial_state", b"_initial_state"]) -> typing.Literal["initial_state"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_num_qubits", b"_num_qubits"]) -> typing.Literal["num_qubits"] | None: ...

Global___CliffordTableau: typing_extensions.TypeAlias = CliffordTableau

@typing.final
class SingleQubitCliffordGate(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TABLEAU_FIELD_NUMBER: builtins.int
    @property
    def tableau(self) -> Global___CliffordTableau: ...
    def __init__(
        self,
        *,
        tableau: Global___CliffordTableau | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["tableau", b"tableau"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["tableau", b"tableau"]) -> None: ...

Global___SingleQubitCliffordGate: typing_extensions.TypeAlias = SingleQubitCliffordGate

@typing.final
class IdentityGate(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    QID_SHAPE_FIELD_NUMBER: builtins.int
    @property
    def qid_shape(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]: ...
    def __init__(
        self,
        *,
        qid_shape: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["qid_shape", b"qid_shape"]) -> None: ...

Global___IdentityGate: typing_extensions.TypeAlias = IdentityGate

@typing.final
class HPowGate(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    EXPONENT_FIELD_NUMBER: builtins.int
    @property
    def exponent(self) -> Global___FloatArg: ...
    def __init__(
        self,
        *,
        exponent: Global___FloatArg | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["exponent", b"exponent"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["exponent", b"exponent"]) -> None: ...

Global___HPowGate: typing_extensions.TypeAlias = HPowGate

@typing.final
class ResetGate(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class ArgumentsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> Global___Arg: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: Global___Arg | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    RESET_TYPE_FIELD_NUMBER: builtins.int
    ARGUMENTS_FIELD_NUMBER: builtins.int
    reset_type: builtins.str
    """Type of reset to be executed (hardware dependent)
    Internal users should use the name of the class.
    (Note that this is not used for public-facing circuits,
     which will default to cirq.ResetChannel)
    """
    @property
    def arguments(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, Global___Arg]:
        """Additional arguments that can be sent to the reset implementation."""

    def __init__(
        self,
        *,
        reset_type: builtins.str = ...,
        arguments: collections.abc.Mapping[builtins.str, Global___Arg] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["arguments", b"arguments", "reset_type", b"reset_type"]) -> None: ...

Global___ResetGate: typing_extensions.TypeAlias = ResetGate
