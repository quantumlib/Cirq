"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import cirq_google.api.v2.metrics_pb2
import cirq_google.api.v2.program_pb2
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _CalibrationLayerCode:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _CalibrationLayerCodeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_CalibrationLayerCode.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    CALIBRATION_RESULT_UNSPECIFIED: _CalibrationLayerCode.ValueType  # 0
    """Zero is a default value and means the value was unknown or unset."""
    SUCCESS: _CalibrationLayerCode.ValueType  # 1
    """Successful run of the calibration."""
    ERROR_OTHER: _CalibrationLayerCode.ValueType  # 2
    """Miscellaenous errors not covered by the below conditions."""
    ERROR_INVALID_PARAMETERS: _CalibrationLayerCode.ValueType  # 3
    """The parameters given to the calibration were not valid.
    For instance, multiple moments were given to a type of calibration
    that expects a single moment.
    """
    ERROR_TIMEOUT: _CalibrationLayerCode.ValueType  # 4
    """The calibration took too long and was aborted."""
    ERROR_CALIBRATION_FAILED: _CalibrationLayerCode.ValueType  # 5
    """The calibration failed for internal reasons.  For instance,
    suitable device parameters could not be acheived or dependencies
    needed by the calibration did not exist.
    """

class CalibrationLayerCode(_CalibrationLayerCode, metaclass=_CalibrationLayerCodeEnumTypeWrapper):
    """Response codes for Calibration requests"""

CALIBRATION_RESULT_UNSPECIFIED: CalibrationLayerCode.ValueType  # 0
"""Zero is a default value and means the value was unknown or unset."""
SUCCESS: CalibrationLayerCode.ValueType  # 1
"""Successful run of the calibration."""
ERROR_OTHER: CalibrationLayerCode.ValueType  # 2
"""Miscellaenous errors not covered by the below conditions."""
ERROR_INVALID_PARAMETERS: CalibrationLayerCode.ValueType  # 3
"""The parameters given to the calibration were not valid.
For instance, multiple moments were given to a type of calibration
that expects a single moment.
"""
ERROR_TIMEOUT: CalibrationLayerCode.ValueType  # 4
"""The calibration took too long and was aborted."""
ERROR_CALIBRATION_FAILED: CalibrationLayerCode.ValueType  # 5
"""The calibration failed for internal reasons.  For instance,
suitable device parameters could not be acheived or dependencies
needed by the calibration did not exist.
"""
global___CalibrationLayerCode = CalibrationLayerCode

@typing.final
class FocusedCalibration(google.protobuf.message.Message):
    """ This message represents a request to execute a custom calibration routine."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LAYERS_FIELD_NUMBER: builtins.int
    @property
    def layers(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___CalibrationLayer]:
        """The layers field represents each invocation of a calibration
        procedure.

        For instance, each (unique) moment of a circuit could be
        calibrated using parallel_xeb.  In this case,
        each moment would have its own CalibrationLayer.

        Some calibrations, such as a readout calibration,
        will only have one layer.
        """

    def __init__(
        self,
        *,
        layers: collections.abc.Iterable[global___CalibrationLayer] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["layers", b"layers"]) -> None: ...

global___FocusedCalibration = FocusedCalibration

@typing.final
class CalibrationLayer(google.protobuf.message.Message):
    """Each CalibrationLayer represents one invocation
    of a calibration procedure.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class ArgsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> cirq_google.api.v2.program_pb2.Arg: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: cirq_google.api.v2.program_pb2.Arg | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    CALIBRATION_TYPE_FIELD_NUMBER: builtins.int
    LAYER_FIELD_NUMBER: builtins.int
    ARGS_FIELD_NUMBER: builtins.int
    calibration_type: builtins.str
    """The type of the calibration procedure to execute.
    The value of this field must be in one of the acceptable
    values found in the cirq enum TBD.
    TODO(dstrain): Point to the cirq enum once it exists.
    """
    @property
    def layer(self) -> cirq_google.api.v2.program_pb2.Program:
        """A circuit that identifies the layer or circuit to optimize
        if the calibration requires this.  For many calibrations,
        this will be a single moment representing the layer to
        optimize for.
        """

    @property
    def args(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, cirq_google.api.v2.program_pb2.Arg]:
        """Arguments that can be specified to the calibration procedure,
        such as the number of layers, which angles to optimize, etc
        """

    def __init__(
        self,
        *,
        calibration_type: builtins.str = ...,
        layer: cirq_google.api.v2.program_pb2.Program | None = ...,
        args: collections.abc.Mapping[builtins.str, cirq_google.api.v2.program_pb2.Arg] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["layer", b"layer"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["args", b"args", "calibration_type", b"calibration_type", "layer", b"layer"]) -> None: ...

global___CalibrationLayer = CalibrationLayer

@typing.final
class FocusedCalibrationResult(google.protobuf.message.Message):
    """The results returned by a FocusedCalibration request."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESULTS_FIELD_NUMBER: builtins.int
    @property
    def results(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___CalibrationLayerResult]:
        """The results of each CalibrationLayer request.
        There will be one CalibrationLayerResults message for each
        CalibrationLayer in the request, and the results will
        correspond to the order of the requests.
        """

    def __init__(
        self,
        *,
        results: collections.abc.Iterable[global___CalibrationLayerResult] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["results", b"results"]) -> None: ...

global___FocusedCalibrationResult = FocusedCalibrationResult

@typing.final
class CalibrationLayerResult(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CODE_FIELD_NUMBER: builtins.int
    ERROR_MESSAGE_FIELD_NUMBER: builtins.int
    TOKEN_FIELD_NUMBER: builtins.int
    METRICS_FIELD_NUMBER: builtins.int
    VALID_UNTIL_MS_FIELD_NUMBER: builtins.int
    code: global___CalibrationLayerCode.ValueType
    """Whether the calibration procedure was a success or failure."""
    error_message: builtins.str
    """On non-successful results, contains additional information
    about the details of the error.
    """
    token: builtins.str
    """A token identifying the calibration result.
    If a token exists in the response, it can be used to tag
    focused circuits that use parameters
    derived from this calibration.
    If no token exists, then the calibration was purely diagnostic.
    """
    valid_until_ms: builtins.int
    """Timestamp of when the calibration is valid until, specified as
    milliseconds since the Unix epoch time.
    """
    @property
    def metrics(self) -> cirq_google.api.v2.metrics_pb2.MetricsSnapshot:
        """Results, such as gate fidelities, gate angles, etc
        would be returned in a similar format to calibration metrics.
        This allows the return result to be easily extensible.
        """

    def __init__(
        self,
        *,
        code: global___CalibrationLayerCode.ValueType = ...,
        error_message: builtins.str = ...,
        token: builtins.str = ...,
        metrics: cirq_google.api.v2.metrics_pb2.MetricsSnapshot | None = ...,
        valid_until_ms: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["metrics", b"metrics"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["code", b"code", "error_message", b"error_message", "metrics", b"metrics", "token", b"token", "valid_until_ms", b"valid_until_ms"]) -> None: ...

global___CalibrationLayerResult = CalibrationLayerResult
