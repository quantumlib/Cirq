"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import cirq_google.api.v2.metrics_pb2
import cirq_google.api.v2.program_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

# Response codes for Calibration requests
class CalibrationLayerCode(_CalibrationLayerCode, metaclass=_CalibrationLayerCodeEnumTypeWrapper):
    pass
class _CalibrationLayerCode:
    V = typing.NewType('V', builtins.int)
class _CalibrationLayerCodeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_CalibrationLayerCode.V], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    # Zero is a default value and means the value was unknown or unset.
    CALIBRATION_RESULT_UNSPECIFIED = CalibrationLayerCode.V(0)
    # Successful run of the calibration.
    SUCCESS = CalibrationLayerCode.V(1)
    # Miscellaenous errors not covered by the below conditions.
    ERROR_OTHER = CalibrationLayerCode.V(2)
    # The parameters given to the calibration were not valid.
    # For instance, multiple moments were given to a type of calibration
    # that expects a single moment.
    ERROR_INVALID_PARAMETERS = CalibrationLayerCode.V(3)
    # The calibration took too long and was aborted.
    ERROR_TIMEOUT = CalibrationLayerCode.V(4)
    # The calibration failed for internal reasons.  For instance,
    # suitable device parameters could not be acheived or dependencies
    # needed by the calibration did not exist.
    ERROR_CALIBRATION_FAILED = CalibrationLayerCode.V(5)

# Zero is a default value and means the value was unknown or unset.
CALIBRATION_RESULT_UNSPECIFIED = CalibrationLayerCode.V(0)
# Successful run of the calibration.
SUCCESS = CalibrationLayerCode.V(1)
# Miscellaenous errors not covered by the below conditions.
ERROR_OTHER = CalibrationLayerCode.V(2)
# The parameters given to the calibration were not valid.
# For instance, multiple moments were given to a type of calibration
# that expects a single moment.
ERROR_INVALID_PARAMETERS = CalibrationLayerCode.V(3)
# The calibration took too long and was aborted.
ERROR_TIMEOUT = CalibrationLayerCode.V(4)
# The calibration failed for internal reasons.  For instance,
# suitable device parameters could not be acheived or dependencies
# needed by the calibration did not exist.
ERROR_CALIBRATION_FAILED = CalibrationLayerCode.V(5)
global___CalibrationLayerCode = CalibrationLayerCode


#  This message represents a request to execute a custom calibration routine.
class FocusedCalibration(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    LAYERS_FIELD_NUMBER: builtins.int
    # The layers field represents each invocation of a calibration
    # procedure.
    #
    # For instance, each (unique) moment of a circuit could be
    # calibrated using parallel_xeb.  In this case,
    # each moment would have its own CalibrationLayer.
    #
    # Some calibrations, such as a readout calibration,
    # will only have one layer.
    @property
    def layers(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___CalibrationLayer]: ...
    def __init__(self,
        *,
        layers : typing.Optional[typing.Iterable[global___CalibrationLayer]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"layers",b"layers"]) -> None: ...
global___FocusedCalibration = FocusedCalibration

# Each CalibrationLayer represents one invocation
# of a calibration procedure.
class CalibrationLayer(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class ArgsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        @property
        def value(self) -> cirq_google.api.v2.program_pb2.Arg: ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Optional[cirq_google.api.v2.program_pb2.Arg] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal[u"value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"key",b"key",u"value",b"value"]) -> None: ...

    CALIBRATION_TYPE_FIELD_NUMBER: builtins.int
    LAYER_FIELD_NUMBER: builtins.int
    ARGS_FIELD_NUMBER: builtins.int
    # The type of the calibration procedure to execute.
    # The value of this field must be in one of the acceptable
    # values found in the cirq enum TBD.
    # TODO(dstrain): Point to the cirq enum once it exists.
    calibration_type: typing.Text = ...
    # A circuit that identifies the layer or circuit to optimize
    # if the calibration requires this.  For many calibrations,
    # this will be a single moment representing the layer to
    # optimize for.
    @property
    def layer(self) -> cirq_google.api.v2.program_pb2.Program: ...
    # Arguments that can be specified to the calibration procedure,
    # such as the number of layers, which angles to optimize, etc
    @property
    def args(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, cirq_google.api.v2.program_pb2.Arg]: ...
    def __init__(self,
        *,
        calibration_type : typing.Text = ...,
        layer : typing.Optional[cirq_google.api.v2.program_pb2.Program] = ...,
        args : typing.Optional[typing.Mapping[typing.Text, cirq_google.api.v2.program_pb2.Arg]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"layer",b"layer"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"args",b"args",u"calibration_type",b"calibration_type",u"layer",b"layer"]) -> None: ...
global___CalibrationLayer = CalibrationLayer

# The results returned by a FocusedCalibration request.
class FocusedCalibrationResult(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    RESULTS_FIELD_NUMBER: builtins.int
    # The results of each CalibrationLayer request.
    # There will be one CalibrationLayerResults message for each
    # CalibrationLayer in the request, and the results will
    # correspond to the order of the requests.
    @property
    def results(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___CalibrationLayerResult]: ...
    def __init__(self,
        *,
        results : typing.Optional[typing.Iterable[global___CalibrationLayerResult]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"results",b"results"]) -> None: ...
global___FocusedCalibrationResult = FocusedCalibrationResult

class CalibrationLayerResult(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CODE_FIELD_NUMBER: builtins.int
    ERROR_MESSAGE_FIELD_NUMBER: builtins.int
    TOKEN_FIELD_NUMBER: builtins.int
    METRICS_FIELD_NUMBER: builtins.int
    VALID_UNTIL_MS_FIELD_NUMBER: builtins.int
    # Whether the calibration procedure was a success or failure.
    code: global___CalibrationLayerCode.V = ...
    # On non-successful results, contains additional information
    # about the details of the error.
    error_message: typing.Text = ...
    # A token identifying the calibration result.
    # If a token exists in the response, it can be used to tag
    # focused circuits that use parameters
    # derived from this calibration.
    # If no token exists, then the calibration was purely diagnostic.
    token: typing.Text = ...
    # Results, such as gate fidelities, gate angles, etc
    # would be returned in a similar format to calibration metrics.
    # This allows the return result to be easily extensible.
    @property
    def metrics(self) -> cirq_google.api.v2.metrics_pb2.MetricsSnapshot: ...
    # Timestamp of when the calibration is valid until, specified as
    # milliseconds since the Unix epoch time.
    valid_until_ms: builtins.int = ...
    def __init__(self,
        *,
        code : global___CalibrationLayerCode.V = ...,
        error_message : typing.Text = ...,
        token : typing.Text = ...,
        metrics : typing.Optional[cirq_google.api.v2.metrics_pb2.MetricsSnapshot] = ...,
        valid_until_ms : builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"metrics",b"metrics"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"code",b"code",u"error_message",b"error_message",u"metrics",b"metrics",u"token",b"token",u"valid_until_ms",b"valid_until_ms"]) -> None: ...
global___CalibrationLayerResult = CalibrationLayerResult
